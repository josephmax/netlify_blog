---
date: 2019-02-22T18:00:30+08:00
tags: 
- 算法
- algorithm
- react
categories:
- 周记
title: 三个常见动态规划问题
---

_Joe按，这篇是探索react diff树算法的番外，顺路理解了一下这三个字符串的算法，下一步会继续研究树的编辑距离算法。_

### 问题1: 求两个字符串之间的编辑距离

所谓的编辑距离，就是从字符串A变成字符串B最少要经历的处理次数。

莱文斯坦距离(Levenshtein)就是其中一种，也是较为常用的编辑距离定义。在莱文斯坦的计算中，修改、新增、删除都算作1次。

这个算法的公式如下:

![IMAGE](/pimg/6461972E82E1656E2A047D4AB86C9E21.jpg)

乍一看很懵，解读一下，lev<sub>a,b</sub>指字符串a和字符串b之间的莱文斯坦距离，i,j表示a,b的长度，当a,b其中一个长度为0时，lev<sub>a,b</sub>等于它们中另一个的长度。其它情况下，lev<sub>a,b</sub>(i,j)等于lev<sub>a,b</sub>(i-1, j) + 1, lev<sub>a,b</sub>(i, j-1) + 1和lev<sub>a,b</sub>(i-1, j-1) + 1<sub>(a<sub>i</sub>&ne;b<sub>j</sub>)</sub>中的最小值。

这么说还是不太直观，但可以读到一个信息，就是每一个lev<sub>a,b</sub>(i,j)都取决于它的lev<sub>a,b</sub>(i-1,j), lev<sub>a,b</sub>(i,j-1)和lev<sub>a,b</sub>(i-1,j-1)，想象一下一个i * j的矩阵, 矩阵里每个值表示lev<sub>a,b</sub>(x,y)，每个值都取决于它上方(lev<sub>a,b</sub>(x,y-1))，左方(lev<sub>a,b</sub>(x-1,y))和左上方(lev<sub>a,b</sub>(x-1,y-1))的值。那么把矩阵填满就能得到lev<sub>a,b</sub>(i,j)。

随手想一个例子实践一下：

把dragon改成legend

第一步先拆解矩阵,填入初始值。

|||||||||
---|:--:|---:|---:|---:|---:|---:|---:|
| | |d|r|a|g|o|n|
| |0|1|2|3|4|5|6|
|l|1|
|e|2|
|g|3|
|e|4|
|n|5|
|d|6|

除去第一行第一列，从有数字的格子开始，为了表达位置，我们假设左上角为[0,0]，右下角为[6,6]。现在开始一行行填入数字吧。

想要填入[1,1]，我们先用一个标识位temp表达它们所代表的字母'd'和'l'是否相同, 相同为0，不同为1，然后比较[0,1] + 1, [1,0] + 1, [0,0] + temp 三格数字，也就是在2,2,1里取最小值，得到1，于是填入1

|||||||||
---|:--:|---:|---:|---:|---:|---:|---:|
| | |d|r|a|g|o|n|
| |0|1|2|3|4|5|6|
|l|1|**<font color=red>1</font>**|
|e|2|
|g|3|
|e|4|
|n|5|
|d|6|

同理继续往下填。。。

|||||||||
---|:--:|---:|---:|---:|---:|---:|---:|
| | |d|r|a|g|o|n|
||0|1|2|3|4|5|6|
|l|1|1|2|3|4|5|6|
|e|2|2|2|3|4|5|6|
|g|3|3|3|3|**<font color=red>3</font>**|
|e|4|
|n|5|
|d|6|
直到[4,3]这一格的时候，第一temp为0，所以[4,3]的最小值为3,继续往下填。。。

|||||||||
---|:--:|---:|---:|---:|---:|---:|---:|
| | |d|r|a|g|o|n|
||0|1|2|3|4|5|6
|l|1|1|2|3|4|5|6|
|e|2|2|2|3|4|5|6
|g|3|3|3|3|3|4|5
|e|4|4|4|4|4|4|5
|n|5|5|5|5|5|5|4
|d|6|5|6|6|6|6|**<font color=red>5</font>**

最后得到的5就表示从dragon->legend的莱文斯坦距离，也就是通过增、删、改最少需要5步从dragon变成legend

这个算法适用于任意长度的两个字符串

||||||
---|:--:|---:|---:|---:
| | |d|o|g
||0|1|2|3
|g|1|1|2|2
|o|2|2|1|2
|d|3|2|2|**<font color=red>2</font>**

[代码实现](https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/levenshtein-distance/levenshteinDistance.js)

我们同时还能得出三个重要的特点：

1. lev<sub>a,b</sub> = 0 当且仅当 a === b（字符串相等）
2. lev<sub>a,b</sub> = lev<sub>b,a</sub> a到b的最小编辑距离和b到a的最小编辑距离相等
3. lev<sub>a,b</sub> + lev<sub>b,c</sub> >= lev<sub>a,c</sub> 就是说a先变成b再变成c需要花的最小步数永远不会小于a直接变成c的最小步数，这与两点之间直线距离最短，三角形两边之和大于第三边的数理逻辑一致。

这个算法有什么用呢？我们可以通过这个算法计算两个词条之间的相似性，举个最直接的例子就是"查询预测"。
假设在某系统存储了许多地址，例如：“北京市海淀区中关村大街1号海龙大厦”。用户输入“北京 海龙大厦”即可查询到这条结果。[栗子在此](http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html)
但这不是我这篇文章关注的重点，同样的思路还能解决什么问题呢？，接下贴两道leetcode上刷到过的题

### 问题2: 求两个字符串之间的最长公共字符串

这个问题相对比问题1好解决一些，同样思路，第一步我们开始构建矩阵,但是矩阵要表示的因素会简单一些，只要表示横纵轴的字母是否相等就能够解决问题了。
我们用1表示相等，0表示不相等，得到如下矩阵:

|||||||
---|:--:|---:|---:|---:|---:|
| |o|n|i|o|n
|i|0|0|1|0|0
|o|1|0|0|1|0
|n|0|1|0|0|1
|i|0|0|1|0|0
|c|0|0|0|0|0

用0表示所在格子表示的横纵向两个字母是否相等，如果某个位置[x,y]的值为1，且[x-1,y-1]的值也为1，那么这两个值就是[x,y],[x-1,y-1]就是它们的公共子串（当然，也可以将[x,y]理解为长度为1的公共子串）所以只要求得所有子串中长度最长的一串便是答案所需要的最长公共子串。

|||||||
---|:--:|---:|---:|---:|---:|
| |o|n|i|o|n|
|i|0|1|**<font color=red>1</font>**|0|0
|o|1|0|0|**<font color=red>1</font>**|0
|n|0|1|0|0|**<font color=red>1</font>**
|i|0|0|1|0|0
|c|0|0|0|0|0

其实光这样已经能够看出最长子串是谁了，但我们可以让矩阵表示的信息更丰富一些，简单修改一下填入数字的逻辑即可。我们在填入数字[x,y]的时候，如果横纵轴字母相同，就将[x,y]的值设为[x-1,y-1] + 1(如果x-1\<0或者y-1\<0，则[x-1,y-1]取0)
这样便能得到如下矩阵

|||||||
---|:--:|---:|---:|---:|---:|
| |o|n|i|o|n|
|i|0|1|**<font color=red>1</font>**|0|0
|o|1|0|0|**<font color=red>2</font>**|0
|n|0|2|0|0|**<font color=red>3</font>**
|i|0|0|3|0|0
|c|0|0|0|0|0

所以由图可见`ion`和`oni`都是onion和ionic的最长子串，长度为3

[代码实现](https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/longest-common-substring/longestCommonSubstring.js)

### 问题3: 求两个字符串之间最长公共子序列
子序列和子串不同，序列只要求顺序正确不要求一模一样，譬如对pig和pg来说最长子序列就是pg，长度为2。

同样这个问题也可以通过构建矩阵来解决，每个格子表示最长子序列的长度

||||||||||||||
---|:--:|--:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|
| | |a|c|c|u|m|u|l|a|t|o|r|
| |0|0|0|0|0|0|0|0|0|0|0|0|
|c|0|
|u|0|
|c|0|
|u|0|
|m|0|
|b|0|
|e|0|
|r|0|

我们在没有公式的情况下根据已知的特征想一想,这个矩阵的特点在于越往右下角走数字越大(毕竟字符串越长，公共子序列就越长) 对于矩阵中的任意位置[x,y]，它的值是否应该取决于[x-1,y],[x,y-1]和[x-1,y-1]? 

我们先来填充第一行

||||||||||||||
---|:--:|--:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|
| | |a|c|c|u|m|u|l|a|t|o|r|
| |0|0|0|0|0|0|0|0|0|0|0|0
|c|0|0|1|1|1|1|1|1|1|1|1|1

对单个字母c来说这样的数据是符合实情的。

继续填充第二行，不难想象如果横纵轴数字不相同，那么[x,y]应该取[x-1,y]或[x,y-1]中较大的那个。如果横纵轴数字相同，那么[x,y]应该等于[x-1,y-1]+1，由此得到

||||||||||||||
---|:--:|--:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|
| | |a|c|c|u|m|u|l|a|t|o|r|
| |0|0|0|0|0|0|0|0|0|0|0|0
|c|0|0|1|1|1|1|1|1|1|1|1|1
|u|0|0|1|1|**<font color=red>2</font>**|2|2|2|2|2|2|2

继续往下填，得到完整答案

||||||||||||||
---|:--:|--:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|
| | |a|c|c|u|m|u|l|a|t|o|r|
| |0|0|0|0|0|0|0|0|0|0|0|0
|c|0|0|1|1|1|1|1|1|1|1|1|1
|u|0|0|1|1|2|2|2|2|2|2|2|2
|c|0|0|1|2|2|2|2|2|2|2|2|2
|u|0|0|1|2|3|3|3|3|3|3|3|3
|m|0|0|1|2|3|4|4|4|4|4|4|4
|b|0|0|1|2|3|4|4|4|4|4|4|4
|e|0|0|1|2|3|4|4|4|4|4|4|4
|r|0|0|1|2|3|4|4|4|4|4|4|**<font color=red>5</font>**

光有这个数字是不够的，我们需要的是最长子序列，回溯一下子序列增长的过程，其实就是靠[x-1, y-1]+1完成增长的，所以我们需要回到每一个增长的节点，把所有引起增长的字符串连起来

||||||||||||||
---|:--:|--:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|
| | |a|c|c|u|m|u|l|a|t|o|r|
| |0|0|0|0|0|0|0|0|0|0|0|0
|c|0|0|**<font color=red>1</font>**|1|1|1|1|1|1|1|1|1
|u|0|0|1|1|2|2|2|2|2|2|2|2
|c|0|0|1|**<font color=red>2</font>**|2|2|2|2|2|2|2|2
|u|0|0|1|2|**<font color=red>3</font>**|3|3|3|3|3|3|3
|m|0|0|1|2|3|**<font color=red>4</font>**|4|4|4|4|4|4
|b|0|0|1|2|3|4|4|4|4|4|4|4
|e|0|0|1|2|3|4|4|4|4|4|4|4
|r|0|0|1|2|3|4|4|4|4|4|4|**<font color=red>5</font>**

[代码实现](https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/sets/longest-common-subsequence/longestCommonSubsequence.js)

### 动态规划

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列。

动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：
（1）问题的阶段
（2）每个阶段的状态
（3）从前一个阶段转化到后一个阶段之间的递推关系。
